# Script originally made by Oscar Guerrero
# Reference: https://orca.cardiff.ac.uk/id/eprint/101322/1/MRSPaper2.pdf

#####################################################################
# READ THIS BEFORE MAKING CHANGES
#
# NOTICE: ANY VARIABLES BEGINNING WITH _ ARE INTERNAL TO THE LAMMPS SCRIPT
#         VARIABLES FOR USE REPLACEMENT BY TEMPLATE HAVE NO _ IN NAME
#
# Parameters for this template:
#   tempstart - The starting temp for the simulation
#   tempstop - The ending temp for the simulation
#   species - A space-separated list of elements present in the system, e.g. "Y Mn O"
#   m3gnet_path - The path to the m3gnet potential installation
#   print_every_n_step - The frequency with which info should be printed to stdout
#   total_steps - The total number of simulation steps
##########################################################################



units  metal
atom_style atomic
boundary p p p

atom_modify map array

#define variables

variable tempstart equal $tempstart
variable tempstop equal $tempstop 
variable myseed equal 12345
variable atomrate equal 1000
variable time_step equal 0.002
variable time_eq equal 1000
#variable tdamp equal 1.

variable tamp equal "v_time_step*1000" # DO NOT CHANGE
variable pdamp equal "v_time_step*1000" # DO NOT CHANGE
timestep ${time_step} # DO NOT CHANGE


#Create structure
read_data data.lammps


#Define Interatomic Potential

pair_style    m3gnet $m3gnet_path
pair_coeff    * *  MP-2021.2.8-EFS   $species

# Equilibration
reset_timestep 0
velocity all create ${tempstart} ${myseed} mom yes rot no dist gaussian
fix equilibration all npt temp ${tempstart} ${tempstart} $(100.0*dt) iso 1 1 ${pdamp} drag 0.2


variable eq1 equal "step"
variable eq2 equal "pxx"
variable eq3 equal "pyy"
variable eq4 equal "pzz"
variable eq5 equal "lx"
variable eq6 equal "ly"
variable eq7 equal "lz"
variable eq8 equal "vol"
variable eq9 equal "temp"
variable eq10 equal "etotal"

fix data_equilibration all print 10 "${eq1} ${eq2} ${eq3} ${eq4} ${eq5} ${eq6} ${eq7} ${eq8} ${eq9} ${eq10}" file ${tempstart}K.data
thermo 1000
thermo_style custom step pxx pyy pzz lx ly lz temp etotal

# RUN
run 1000

# store final volume Vo to calculate V/Vo (reduce units)
variable tmp equal "vol"
variable Vo equal ${tmp}
print "Volume initial is , Vo: ${Vo}"

#reset
unfix equilibration
unfix data_equilibration

#----------------------------- Increase temperature------------------------------------
reset_timestep 0
fix melting all npt temp ${tempstart} ${tempstop} $(100.0*dt) iso 1 1 ${pdamp} drag 0.2
# fix melting all nvt temp ${tempstart} ${tempstop} ${tdamp} drag 0.2

variable eq1 equal "step"
variable eq2 equal "pxx"
variable eq3 equal "pyy"
variable eq4 equal "pzz"
variable eq5 equal "lx"
variable eq6 equal "ly"
variable eq7 equal "lz"
variable eq8 equal "temp"
variable eq9 equal "vol/v_Vo"
variable eq10 equal "etotal"
run 0 
fix data_melting all print $print_every_n_step "${eq8} ${eq9}" file temp_vs_ref_vol.txt screen no

dump 1 all cfg 100 step*.cfg mass type xs ys zs id
# What does this do? so the element str can be written to the cfg file
dump_modify 1 element  $species

dump 2 all custom 100 trajectory.lammpstrj id element x y z
dump_modify   2 sort id element $species
# dump all the dump files into one file trajectory.lammpstrj 

# wildcard * is used to dump all the snapshots into invividual files
dump 3 all custom  100  dump.* id type x y z

# Compute msd command and dump every 10 steps
compute msd all msd com yes
fix msd all ave/time 1 1 10 c_msd[4] file msd.txt

group lithium type 1
# group lanthanum type 2
# group zirconium type 3
# group oxygen type 4

compute           mymsd1 lithium msd com yes   
# compute ID(mymsd) group-ID(lithium) msd keyword(com)values(yes: If the com option is set to yes
#  then the effect of any drift in the center-of-mass of the group of atoms is subtracted out 
# before the displacement of each atom is calculated.)
variable          msdxLi equal "c_mymsd1[1]"
variable          msdyLi equal "c_mymsd1[2]"
variable          msdzLi equal "c_mymsd1[3]"
variable          msdtotLi equal "c_mymsd1[4]"
fix               msdT1 lithium ave/time 1 1 1000 v_msdxLi v_msdyLi v_msdzLi v_msdtotLi file msd_Li.dat 
#fix ID group-ID ave/time Nevery Nrepeat Nfreq value1 value2 ... keyword args ... 
# For example, if Nevery=2, Nrepeat=6, and Nfreq=100, then values on timesteps 90,92,94,96,98,100 will be used to compute the final average on timestep 100. 
# Similarly for timesteps 190,192,194,196,198,200 on timestep 200, etc.
# If Nrepeat=1 and Nfreq = 100, then no time averaging is done; values are simply generated on timesteps 100,200,etc. (v_msdx v_msdy v_msdz v_msdtot)


# use velocity auto-correlation function (VACF) to calculate diffusion coefficient
compute         2 all vacf
fix             5 all vector 1 c_2[4]
variable        diff equal dt*trap(f_5)
fix    vacf all print 1 "${eq1} ${eq8} ${eq9} ${diff}"

run $total_steps 
thermo $print_every_n_step
thermo_style    custom step v_diff


# print to screen out

#run 10000
#reset 
unfix melting 
unfix data_melting 
undump 1
undump 2
undump 3
write_restart restart.equil
write_data data.*
# SAVE THE DATA OF THE CALCULATION OR ELSE YOU NEED TO START OVER = ( OUCH !
# SIMULATION DONE
clear
print "Simulation done! You have done great job!"


